<!DOCTYPE html>
<meta charset="utf-8">

<!-- Load d3.js -->
<script src="https://d3js.org/d3.v5.js"></script>

<!-- Create a div where the graph will take place -->
<div id="my_dataviz"></div>



<script>

    // set the dimensions and margins of the graph
    var margin = {top: 10, right: 30, bottom: 30, left: 60},
        width = 800 - margin.left - margin.right,
        height = 400 - margin.top - margin.bottom;

    // append the svg object to the body of the page
    var svg = d3.select("#my_dataviz")
        .append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .append("g")
        .attr("transform",
            "translate(" + margin.left + "," + margin.top + ")");


    //Read the data
    function draw(data) {

        var pais = "USA"
        var dados = []


        data.forEach(filter)
        function filter(entry){
            if (entry["country"] === pais) {
                dados.push(entry)
            }
        }
        var i = 0
        dados = dados.reduce((a, {year, suicides_no, gdp_per_capita}) => {
            a[year] = a[year] || {year, suicides_no: 0};
            a[year].suicides_no += parseInt(suicides_no);
            return a;
        }, [])

        data = []
        for (var entry in dados) {
            data.push({"year": parseInt(dados[entry]["year"]) ,"suicides": dados[entry]["suicides_no"]})
        }

        console.log(data)

            // Add X axis
            var x = d3.scaleLinear()
                .domain([d3.min(data, function(d) { return d.year; }),d3.max(data, function(d) { return d.year; })])
                .range([ 0, width -100]);
            svg.append("g")
                .attr("transform", "translate(0," + height + ")")
                .call(d3.axisBottom(x));

            // Add Y axis
            var y = d3.scaleLinear()
                .domain([0, d3.max(data, function(d) { return +d.suicides; })])
                .range([ height, 0 ]);
            svg.append("g")
                .call(d3.axisLeft(y));


        // Set the gradient
            // Max value observed:
        const max = d3.max(data, function(d) { return +d.suicides; })
        const min = d3.min(data, function(d) { return d.suicides; })
        svg.append("linearGradient")
            .attr("id", "line-gradient")
            .attr("gradientUnits", "userSpaceOnUse")
            .attr("x1", 0)
            .attr("y1", y(min))
            .attr("x2", 0)
            .attr("y2", y(max))
            .selectAll("stop")
            .data([
                {offset: "0%", color: "blue"},
                {offset: "100%", color: "red"}
            ])
            .enter().append("stop")
            .attr("offset", function(d) { return d.offset; })
            .attr("stop-color", function(d) { return d.color; });



        // This allows to find the closest X index of the mouse:
        var bisect = d3.bisector(function(d) { return d.year; }).left;

        // Create the circle that travels along the curve of chart
        var focus = svg
            .append('g')
            .append('circle')
            .style("fill", "none")
            .attr("stroke", "black")
            .attr('r', 8.5)
            .style("opacity", 0)

        // Create the text that travels along the curve of chart
        var focusText = svg
            .append('g')
            .append('text')
            .style("opacity", 0)
            .attr("text-anchor", "left")
            .attr("alignment-baseline", "middle")







        // Add the line
            svg.append("path")
                .datum(data)
                .attr("fill", "none")
                .attr("stroke", "url(#line-gradient)")
                .attr("stroke-width", 1.5)
                .attr("d", d3.line()
                    .x(function(d) { return x(d.year) })
                    .y(function(d) { return y(d.suicides) })
                )



        // Create a rect on top of the svg area: this rectangle recovers mouse position
        svg.append('rect')
            .style("fill", "none")
            .style("pointer-events", "all")
            .attr('width', width)
            .attr('height', height)
            .on('mouseover', mouseover)
            .on('mousemove', mousemove)
            .on('mouseout', mouseout);


        // What happens when the mouse move -> show the annotations at the right positions.
        function mouseover() {
            focus.style("opacity", 1)
            focusText.style("opacity",1)
        }

        function mousemove() {
            // recover coordinate we need
            var x0 = x.invert(d3.mouse(this)[0]);
            var i = bisect(data, x0, 1);
            selectedData = data[i]
            console.log((selectedData.suicides))
            focus
                .attr("cx", x(selectedData.year))
                .attr("cy", y(selectedData.suicides))
            focusText
                .html("x:" + selectedData.year + "  -  " + "y:" + selectedData.suicides)
                .attr("x", x(selectedData.year)+15)
                .attr("y", y(selectedData.suicides))
        }
        function mouseout() {
            focus.style("opacity", 0)
            focusText.style("opacity", 0)
        }



        data.forEach(function (item, index) {
            if (item.year == year){
                suicides = item.suicides;
                gdp = item.gdpPerCap;
            }
        });
        }



</script>
<script>
    d3.csv("master.csv")
        .then(draw)
        .catch(function(err){console.log(err)});
</script>